const moment = require('moment-timezone');
const XlsxGenerator = require('./xlsx-generator');
const Decimal = require('decimal.js');
const { format: formatCurrency } = require('currency-formatter');

const SUMMARY_SHEET_NAME = 'Summary';

const {
  studio_invoice: StudioInvoices,
  dibs_transaction: DibsTransactions,
  dibs_studio: DibsStudios,
  dibs_user: DibsUsers,
  event: Events,
  dibs_studio_instructors: DibsStudioInstructors,
  passes: Passes,
  studio_packages: Packages,
} = models;

const invoiceIncludeConfig = [{
  model: DibsStudios,
  as: 'studio',
  attributes: [
    'name',
    'country',
    'mainTZ',
  ],
}, {
  model: DibsTransactions,
  as: 'transactions',
  paranoid: false,
  attributes: [
    'id',
    [sequelize.literal('"transactions"."amount" - COALESCE("transactions"."studio_credits_spent", 0) - COALESCE("transactions"."raf_credits_spent", 0)'), 'amount'],
    [sequelize.literal('COALESCE("transactions"."studio_credits_spent", 0)'), 'credits_spent'],
    'tax_withheld',
    'global_credit_adjustment',
    'stripe_fee',
    'dibs_fee',
    'studio_payment',
    'createdAt',
    'eventid',
    'purchasePlace',
  ],
  include: [{
    model: DibsUsers,
    as: 'user',
    paranoid: false,
    attributes: [
      'firstName',
      'lastName',
      'email',
    ],
  }, {
    model: Events,
    as: 'event',
    attributes: [
      'name',
      'start_date',
      'trainerid',
      'source',
      'studioid',
    ],
  }, {
    model: Passes,
    as: 'passPurchased',
    paranoid: false,
    include: [{
      model: Packages,
      as: 'studioPackage',
    }],
  }],
}];

const getInvoiceLocationName = invoice => (invoice.locationName || 'Bookings');

/**
 * getInvoiceSpreadsheetName
 * @param {Object} invoice instance of the invoice model
 * @param {boolean} addXlsxExtension to the end of the filename if true
 * @returns {string} filename of the spreadsheet
 */
function getInvoiceSpreadsheetName(invoice, addXlsxExtension = true) {
  let filename = invoice.studio.name.split(' ')
                                    .map(str => str[0])
                                    .join('')
                                    .replace(/[.,/#!?$%^&*;:{}=\-_`~()+]/g, '')
                                    .toUpperCase();
  filename += `_${moment(invoice.end_date).format('MMDDYY')}`;
  if (addXlsxExtension) filename += '.xlsx';
  return filename;
}

/**
 * getFormattedInvoiceDateRange
 * @param {Object} invoice instance of the invoice model
 * @returns {string} naturally formatted date range
 */
function getFormattedInvoiceDateRange(invoice) {
  const dateFormat = invoice.studio.country === 'UK' ? 'D.M.YYYY' : 'M.D.YYYY';
  let dateRange = moment(invoice.start_date).format(dateFormat);
  dateRange += ` - ${moment(invoice.end_date).subtract(1, 'day').format(dateFormat)}`;
  return dateRange;
}

/**
 * getTransactionTotals
 * @param {Array<Object>} transactions the array of transaction instances
 * @param {string} currency code for the studio
 * @returns {Object} with totals for all numeric transaction keys
 */
function getTransactionTotals(transactions, currency) {
  const totals = transactions.reduce((acc, transaction) => {
    Object.keys(transaction.dataValues).forEach((key) => {
      if (typeof transaction[key] !== 'number' || key === 'id') return;
      if (!acc[key]) acc[key] = new Decimal(transaction[key]);
      else acc[key] = acc[key].plus(transaction[key]);
    });
    return acc;
  }, {});
  Object.keys(totals).forEach((key) => {
    const value = totals[key].toNumber();
    if (value === 0 && key === 'global_credit_adjustment') {
      delete totals[key];
      return;
    }
    totals[key] = formatCurrency(value, { code: currency });
    if (key !== 'amount' && key !== 'studio_payment') {
      totals[key] = `(${totals[key]})`;
    }
  });
  totals.numberOfTransactions = transactions.length;
  return totals;
}

/**
 * populateTransactionTotals
 * @param {XlsxGenerator} xlsx the instance of the xlsx generator class
 * @param {Object} transactionTotals totals of the invoice transactions
 * @param {boolean} includeNumberOfTransactions if true, includes the total number of transactions
 * @returns {number} number of rows in the spreadsheet generated by this function
 */
function populateTransactionTotals(xlsx, transactionTotals, includeNumberOfTransactions = true) {
  const initialCoords = xlsx.currentCellCoords;
  const labelValues = [
    'Gross Revenue',
    'Tax Withheld',
  ];
  const values = [
    transactionTotals.amount,
    transactionTotals.tax_withheld,
  ];

  if (transactionTotals.global_credit_adjustment) {
    labelValues.push('Global Credit Adjustment');
    values.push(transactionTotals.global_credit_adjustment);
  }

  labelValues.push(
    'Credit Card Fees',
    'Dibs Fee'
  );
  values.push(
    transactionTotals.stripe_fee,
    transactionTotals.dibs_fee
  );

  if (includeNumberOfTransactions) {
    labelValues.unshift('Total Transactions', '');
    values.unshift(transactionTotals.numberOfTransactions, '');
  }

  xlsx.editCells({
    direction: [1, 0],
    values: labelValues,
  });
  xlsx.moveToRelativeCell(0, 1);
  xlsx.editCells({
    direction: [1, 0],
    style: { alignment: 'right' },
    values,
  });
  xlsx.moveToRelativeCell(values.length, -1);
  xlsx.currentCell.style(xlsx.getCellStyle({ border: { top: '000000' } }));
  xlsx.currentCell.string('Total Payment');
  xlsx.moveToRelativeCell(0, 1);
  xlsx.currentCell.style(xlsx.getCellStyle({ border: { top: '000000' }, alignment: 'right' }));
  xlsx.currentCell.string(transactionTotals.studio_payment);
  xlsx.setCurrentCell(...initialCoords);

  return values.length + 1;
}

/**
 * populateInvoiceSheet
 * @param {XlsxGenerator} xlsx the instance of the xlsx generator class
 * @param {Object} invoice with association transactions
 * @returns {undefined}
 */
async function populateInvoiceSheet(xlsx, invoice) {
  const transactionTotals = getTransactionTotals(invoice.transactions, invoice.currency);
  const trainerids = invoice.transactions.filter(t => t.eventid !== null).map(t => t.event.trainerid);
  let instructors;
  if (trainerids.length) {
    instructors = await DibsStudioInstructors.findAll({
      where: { id: trainerids },
    });
  }

  // SHEET COLUMN/ROW SIZES
  xlsx.setSheetCellDimensions({
    rows: { 1: 40, 6: 14, 10: 14, 11: 25 },
    columns: { 1: 30, 4: 20, 5: 25, 6: 20, 9: 20, 10: 8, 12: 20, 13: 25 },
  });

  // HEADING
  xlsx.setCurrentCell(1, 1);
  xlsx.editCells({
    steps: 13,
    direction: [0, 1],
    style: { fill: 'dddddd' },
  });
  xlsx.addImage(`${__dirname}/images/dibs_logo_white.png`, { x: '1mm', y: '1.5mm' });
  xlsx.setCurrentCell(2, 1);
  xlsx.editCells({
    direction: [1, 0],
    values: [
      `${invoice.studio.name} - ${getInvoiceLocationName(invoice)}`,
      invoice.address,
      `${invoice.city} ${invoice.zipCode}`,
    ],
  });
  xlsx.setCurrentCell(2, 12);
  xlsx.editCells({
    direction: [1, 0],
    values: [
      'Invoice Name',
      'Date Range',
    ],
  });
  xlsx.setCurrentCell(2, 13);
  xlsx.editCells({
    direction: [1, 0],
    style: { alignment: 'right' },
    values: [
      getInvoiceSpreadsheetName(invoice, false),
      getFormattedInvoiceDateRange(invoice),
    ],
  });

  // SUMMARY SECTION
  xlsx.setCurrentCell(6, 1);
  xlsx.editCells({
    steps: 13,
    direction: [0, 1],
    style: { fill: 'dddddd' },
  });
  xlsx.currentCell.string('PAYMENT SUMMARY');
  xlsx.setCurrentCell(7, 1);
  xlsx.editCells({
    direction: [1, 0],
    values: [
      'Total Transactions',
      'Gross Revenue',
    ],
  });
  xlsx.setCurrentCell(7, 2);
  xlsx.editCells({
    direction: [1, 0],
    style: { alignment: 'right' },
    values: [
      transactionTotals.numberOfTransactions,
      transactionTotals.amount,
    ],
  });

  // TRANSACTION RECORD HEADING
  xlsx.setCurrentCell(10, 1);
  xlsx.editCells({
    steps: 13,
    direction: [0, 1],
    style: { fill: 'dddddd' },
  });
  xlsx.currentCell.string('TRANSACTION RECORD');
  xlsx.setCurrentCell(11, 1);
  xlsx.editCells({
    direction: [0, 1],
    values: [
      'Transaction No.',
      'Date\nPurchased:',
      'Time\nPurchased:',
      'Client Name:',
      'Email:',
      invoice.locationid ? 'Class Name:' : 'Product Name:',
      'Class Date:',
      'Class Time:',
      'Instructor:',
      'Offsite:',
      'Credit\nApplied:',
      'Tax Withheld:',
      'Amount Charged:',
    ],
  });

  // TRANSACTION RECORD SECTION
  const dateFormat = invoice.studio.country === 'UK' ? 'D/M/YYYY' : 'M/D/YYYY';
  invoice.transactions.forEach((transaction, i) => {
    const transactionCreatedAt = moment(transaction.createdAt).tz(invoice.studio.mainTZ);
    const { user, event } = transaction;
    let eventStart;
    let instructor;
    if (event) {
      eventStart = moment(event.start_date).utc();
      instructor = instructors.find(ins => (
        ins.id === event.trainerid
        && ins.source === event.source
        && ins.studioid === event.studioid
      ));
    }
    xlsx.setCurrentCell(12 + i, 1);
    xlsx.editCells({
      direction: [0, 1],
      values: [
        transaction.id,
        transactionCreatedAt.format(dateFormat),
        transactionCreatedAt.format('HH:mm'),
        `${user.firstName} ${user.lastName}`,
        user.email,
        (event && event.name) || (transaction.passPurchased && transaction.passPurchased.studioPackage.normalizedName) || 'Credit',
        event ? eventStart.format(dateFormat) : 'N/A',
        event ? eventStart.format('HH:mm') : 'N/A',
        event ? `${instructor.firstname} ${instructor.lastname}` : 'N/A',
      ],
    });
    xlsx.setCurrentCell(12 + i, 10);
    xlsx.editCells({
      direction: [0, 1],
      style: { alignment: 'right' },
      values: [
        transaction.purchasePlace === 'offsite' ? 'x' : '',
        event ? formatCurrency(transaction.dataValues.credits_spent, { code: invoice.currency }) : 'N/A',
        formatCurrency(transaction.tax_withheld, { code: invoice.currency }),
        formatCurrency(transaction.amount, { code: invoice.currency }),
      ],
    });
  });

  // TOTAL SECTION
  xlsx.setCurrentCell(13 + transactionTotals.numberOfTransactions, 12);
  populateTransactionTotals(xlsx, transactionTotals, false);
}

/**
 * getInvoiceXlsx
 * @param {Object} invoice from the query in the module's main function
 * @param {string} dirname of the module this function is called in
 * @returns {string} the name of the saved spreadsheet
 */
async function getInvoiceXlsx(invoice, dirname) {
  const xlsx = new XlsxGenerator();
  const filename = getInvoiceSpreadsheetName(invoice);
  xlsx.initNewWorkbook();
  xlsx.nameCurrentSheet(getInvoiceSpreadsheetName(invoice, false));
  await populateInvoiceSheet(xlsx, invoice);
  await xlsx.writeToFile(`${dirname}/${filename}`);
}

/**
 * getTotalInvoiceXlsx
 * @param {Object} totalInvoice from the query in the module's main function
 * @param {string} dirname of the module this function is called in
 * @returns {string} the name of the saved spreadsheet
 */
async function getTotalInvoiceXlsx(totalInvoice, dirname) {
  const xlsx = new XlsxGenerator();
  const filename = getInvoiceSpreadsheetName(totalInvoice);
  let invoices = await StudioInvoices.findAll({
    where: {
      dibs_studio_id: totalInvoice.dibs_studio_id,
      start_date: totalInvoice.start_date,
      studio_total: false,
    },
    order: [[{ model: DibsTransactions, as: 'transactions' }, 'createdAt', 'ASC']],
    include: invoiceIncludeConfig,
  });
  const allTransactions = invoices.reduce((acc, { transactions }) => {
    acc.push(...transactions);
    return acc;
  }, []);
  const allTransactionTotals = getTransactionTotals(allTransactions, totalInvoice.currency);

  xlsx.initNewWorkbook();
  xlsx.nameCurrentSheet(SUMMARY_SHEET_NAME);

  // SETTING COLUMN SIZE FOR SUMMARY SUMMARY
  xlsx.setSheetCellDimensions({
    rows: { 1: 40 },
    columns: { 1: 25, 2: 25 },
  });

  // HEADING
  xlsx.editCells({
    steps: 2,
    direction: [0, 1],
    style: { fill: 'dddddd' },
  });
  xlsx.addImage(`${__dirname}/images/dibs_logo_white.png`, { x: '1mm', y: '1.5mm' });
  xlsx.setCurrentCell(2, 1);
  xlsx.editCells({
    direction: [1, 0],
    values: [
      totalInvoice.studio.name,
      'Invoice Name',
      'Date Range',
    ],
  });
  xlsx.setCurrentCell(3, 2);
  xlsx.editCells({
    direction: [1, 0],
    style: { alignment: 'right' },
    values: [
      getInvoiceSpreadsheetName(totalInvoice, false),
      getFormattedInvoiceDateRange(totalInvoice),
    ],
  });

  // TOTAL INVOICE SECTION
  xlsx.setCurrentCell(6, 1);
  xlsx.editCells({
    steps: 2,
    direction: [0, 1],
    style: { fill: 'dddddd' },
  });
  xlsx.currentCell.string('PAYMENT SUMMARY');
  xlsx.setCurrentCell(7, 1);
  xlsx.editCells({
    steps: 2,
    direction: [0, 1],
    style: { fill: 'ffff00' },
  });
  xlsx.currentCell.string('TOTAL:');
  xlsx.setCurrentCell(8, 1);
  populateTransactionTotals(xlsx, allTransactionTotals);

  // INVOICE BREAKDOWN
  invoices = await Promise.map(invoices, invoice => invoice.getGeographicInfo());
  let currentRow = 17;
  await Promise.each(invoices, async (invoice) => {
    const transactionTotals = getTransactionTotals(invoice.transactions, totalInvoice.currency);
    xlsx.setCurrentCell(currentRow, 1);
    xlsx.editCells({
      steps: 2,
      direction: [0, 1],
      style: { fill: 'dddddd' },
    });
    xlsx.currentCell.string(`${totalInvoice.studio.name} - ${getInvoiceLocationName(invoice)}`);
    currentRow += 1;
    xlsx.setCurrentCell(currentRow, 1);
    currentRow += 1 + populateTransactionTotals(xlsx, transactionTotals);

    // Creates sheet for broken down invoice
    xlsx.addNewSheet(getInvoiceLocationName(invoice));
    xlsx.setCurrentSheet(getInvoiceLocationName(invoice));
    await populateInvoiceSheet(xlsx, invoice);

    // Resets current sheet for next iteration
    xlsx.setCurrentSheet(SUMMARY_SHEET_NAME);
  });

  await xlsx.writeToFile(`${dirname}/${filename}`);
}

/**
 * Create invoice spreadsheeet
 * @param {number} invoiceId the id of the invoice used for spreadsheet
 * @param {string} dirname where the directory where the xlsx will be written to
 * @returns {Promise<undefined>} creates the invoice spreadsheet
 */
async function createInvoiceXlsx(invoiceId, dirname) {
  let invoice = await StudioInvoices.findById(invoiceId, {
    include: invoiceIncludeConfig,
    order: [[{ model: DibsTransactions, as: 'transactions' }, 'createdAt', 'ASC']],
  });
  invoice = await invoice.getGeographicInfo();
  return (invoice.studio_total ? getTotalInvoiceXlsx : getInvoiceXlsx)(invoice, dirname);
}

module.exports = {
  getInvoiceSpreadsheetName,
  createInvoiceXlsx,
};
