const stripe = require('stripe');
const Decimal = require('decimal.js');
const moment = require('moment');
const countryRegions = require('../helpers/api/country-regions.json');

const {
  USD_STRIPE_FEE_PERECENTAGE,
  USD_STRIPE_FEE_FIXED,
  GBP_EURO_CARD_STRIPE_FEE_PERCENTAGE,
  GBP_NON_EURO_CARD_STRIPE_FEE_PERCENTAGE,
  GBP_STRIPE_FEE_FIXED,
  RefundTypes,
} = require('./constants');

/**
 * @class StripeClient
 */
class StripeClient {
  /**
   * @static
   * @param {number} amount in units of currency
   * @returns {number} amount converted for Stripe API calls
   */
  static convertAmount(amount) {
    return Decimal(amount).toDP(2).times(100).toNumber();
  }

  /**
   * @constructor
   * @constructs StripeClient
   */
  constructor() {
    this.stripe = stripe(process.env.STRIPE_API_KEY);
    // this.stripeNew = stripe(process.env.STRIPE_API_KEY, {
    //   apiVersion: '2020-03-02',
    // });
  }


  /**
   * @method
   * @param {Object} args                 args to create customer
   * @param {string} args.email           email associated to the Dibs user
   * @param {string} args.managedAccount  stripe_account_id to create customer
   * @returns {Promise<Object>} resolves response from Stripe
   */
  createCustomer({
    email,
    source,
    managedAccount,
  }) {
    return this.stripe.customers.create({ 
        email, 
        source: source,
      },
      { stripe_account: managedAccount }
    );
  }

  /**
   * @method
   * @param {string} customerId associated to the Dibs user
   * @param {string} managedAccount studio account id on Stripe Connect
   * @returns {Promise<Object>} resolves response from Stripe
   */
  createCustomerToken({
    customerId,
    managedAccount,
  }) {
    return this.stripe.tokens.create({
      customer: customerId,
    }, { stripe_account: managedAccount });
  }

  /**
   * @method
   * @param {Object} args                 object contains named arguments
   * @param {Object} args.stripeUserId    who owns card
   * @param {number} ags.cardNumber       the card num
   * @param {Object} args.expiration      the card expiration, has month, year keys
   * @param {number} args.cvc             the card CVC
   * @param {string} args.managedAccount  the managedAccount to use
   * @param {Object} args.sourceToken     the source to use
   * @returns {Promise<Object>} resolves the stripe response
   */
  createCard({
    stripeUserId,
    cardNumber,
    expiration,
    cvc,
    managedAccount,
    sourceToken,
  }) {
    return this.stripe.customers.createSource(stripeUserId, {
      source: sourceToken || {
        object: 'card',
        exp_month: expiration.month,
        exp_year: expiration.year,
        number: String(cardNumber).trim().replace(/ /, ''),
        cvc,
      },
    }, { stripe_account: managedAccount });
  }

  /**
   * @param {string} stripeUserId of user entering card info
   * @param {string} token id generated by Stripe front end lib
   * @returns {Promise<Object>} stripe source
   */
  createCardFromToken(stripeUserId, token) {
    return this.stripe.customers.createSource(stripeUserId, { source: token });
  }

  /**
   * @method
   * @param {Object} user whose card is getting deleted
   * @returns {Promise<Object>} resolves Stripe response
   */
  deleteCard({
    stripeUserId,
    stripeCardId,
  }) {
    return this.stripe.customers.deleteCard(stripeUserId, stripeCardId);
  }

  /**
   * @method
   * @param {Object} stripeUserId whose card is being updated
   * @param {string} stripeCardId of the card being set to their new card
   * @param {string} managedAccount of the connected account to set their card for
   * @returns {Promise<Object>} resolves response from Stripe
   */
  updateDefaultCard({
    stripeUserId,
    stripeCardId,
    managedAccount,
  }) {
    return this.stripe.customers.update(
      stripeUserId,
      { default_source: stripeCardId },
      { stripe_account: managedAccount }
    );
  }

  /**
   * @method
   * @param {Object} user whose sanitized card info we are getting
   * @returns {Promise<Object>} resolves Stripe response
   */
  lastFour(user) {
    return this.stripe.customers.retrieveCard(user.stripeid, user.stripe_cardid);
  }

  /**
   * @method
   * @param {Object} user whose sanitized card info we are getting
   * @returns {Promise<Object>} resolves Stripe response
   */
  lastFourUpdatedStripe(user) {
    return this.stripe.customers.retrieveSource(user.stripeid, user.stripe_cardid);
  }

  /**
   * @method
   * @param {Object} user whose sanitized card info we are getting
   * @returns {Promise<Object>} resolves Stripe response
   */
  lastFourPortalUser(user) {
    return this.stripe.customers.retrieveCard(user.stripe_customer_id, user.stripe_card_id);
  }

  /**
   * @method
   * @param {Object}  args object contains      named arguments
   * @param {Object}  args.customerId           stripe user id charge is for
   * @param {number}  args.amount               for charge, in units of provided currency
   * @param {string}  args.currency             of charge
   * @param {string}  args.descrption           of the charge
   * @param {boolean} args.capture              if false, only puts a hold on the card
   * @param {string}  args.account              accound id for connected accounts
   * @param {string}  args.statementDescriptor  shows up on the customer's credit card bill
   * @param {number}  args.applicationFee dibs  fee + tax withheld
   * @returns {Promise<Object>} resolves response from Stripe
   */
  chargeCard({
    customerId,
    amount,
    currency = 'usd',
    description = '',
    capture = true,
    account,
    statementDescriptor,
    applicationFee,
  }) {
    const params = {
      amount: StripeClient.convertAmount(amount),
      capture,
      currency,
      customer: customerId,
      description,
      expand: [
        'balance_transaction',
      ],
      statement_descriptor_suffix: statementDescriptor.substring(0, 22).toUpperCase(),
    };
    if (account) {
      // required stripe update
      params.application_fee_amount = StripeClient.convertAmount(applicationFee);
      // old --> params.application_fee = StripeClient.convertAmount(applicationFee);
    }
    return this.stripe.charges.create(params, { stripe_account: account });
  }

  /**
   * @method
   * @param {Object} args object same schema as the argument of chargeCard
   * @returns {Promise<Object>} resolves response from Stripe
   */
  preChargeCard(args) {
    return this.chargeCard({ ...args, capture: false });
  }

  /**
   * @method
   * @param {string} chargeId of the hold getting completed
   * @param {number} amount to capture for the charge
   * @param {String} account studio account id
   * @returns {Promise<Object>} resolves response from Stripe
   */
  completeCharge({
    chargeId,
    amount,
    account,
  }) {
    return this.stripe.charges.capture(chargeId, {
      amount: StripeClient.convertAmount(amount),
      expand: [
        'balance_transaction',
      ],
    }, { stripe_account: account });
  }

  /**
   * @method
   * @param {string} chargeId Stripe charge id of charge being refunded
   * @param {Object} options                      object
   * @param {number} options.amount               to refund in units of currency
   * @param {string} options.reason               for refund
   * @param {string} options.stripeAccountId      if there is a stripe account id, we create a refund on the stripe account
   * @returns {Promise<Object>} resolves Stripe response
   */
  async refund(chargeId, {
    amount,
    reason = '',
    stripeAccountId = null,
  } = {}) {
    const {
      refundType,
      refundApplicationFee,
    } = await this.getRefundType(stripeAccountId, chargeId);
    const refund = {
      charge: chargeId,
      refund_application_fee: refundApplicationFee,
    };

    if (reason) refund.reason = reason;
    if (amount) refund.amount = StripeClient.convertAmount(amount);

    return refundType === RefundTypes.MANAGED_ACCOUNT ?
      this.stripe.refunds.create(refund, {
        stripe_account: stripeAccountId,
      }) :
      this.stripe.refunds.create({ ...refund,
        reverse_transfer: refundType === RefundTypes.PLATFORM_REVERSE_TRANSFER,
      });
  }

  /**
   * @method
   * @param {string} chargeId stripe charge id you want details for
   * @param {string} accountId stripe account id you want details for
   * @return {Promise<Object>} Stripe resonse
   */
  retrieveChargeDetails(chargeId, accountId) {
    return this.stripe.charges.retrieve(chargeId, {
      expand: [
        'application_fee',
        'balance_transaction',
      ],
    }, { stripe_account: accountId });
  }

  /**
   * @method
   * @param {Object} args               object contains named arguments
   * @param {string} args.country       where studio is in
   * @param {string} args.firstName     of the account owner
   * @param {string} args.lastName      of the account owner
   * @param {string} args.ip address    of the business
   * @param {Object} args.dateOfBirth   of the owner, has keys: month, day, year
   * @param {string} args.businessName  name of the business w the connected account
   * @param {string} args.businessPhone phone of the business w the connected account
   * @param {stirng} args.businessURL   url for the business w the connected account
   * @param {Object} args.address       of the business, has keys: line1, line2?, city, state?, postalCode
   * @param {string} args.businessTaxId tax identifier
   * @returns {Promise<Object>} resolves Stripe response
   */
  createManagedAccount({
    country,
    // firstName,
    // lastName,
    ip,
    // dateOfBirth,
    businessName,
    businessPhone,
    businessURL,
    address,
    businessTaxId,
    // last4,
    externalAccount,
  }) {
    console.log('Setting the stripe API version');
    this.stripe.setApiVersion('2020-03-02');
    return this.stripe.accounts.create({
      type: 'custom',
      country,
      requested_capabilities: [
        'card_payments',
        'transfers',
      ],
      business_type: 'company',
      company: {
        name: businessName,
        phone: businessPhone,
        address: {
          city: address.city,
          country,
          line1: address.line1,
          line2: address.line2 || null,
          postal_code: address.postalCode,
          state: address.state || null,
        },
        tax_id: businessTaxId,
      },
      business_profile: {
        url: businessURL,
        mcc: '7997',
      },
      external_account: externalAccount,
      tos_acceptance: {
        ip,
        date: moment().utc().unix(),
      },
      // https://stripe.com/docs/connect/required-verification-information#minimum-verification-requirements-for-united-states
      // with new api - don't pass ssn_info yet - get it after the client has started making transactions - pass to the persons API
      // required stripe changes --> update API version
      // managed: true,
      // business_url: 'www.ondibs.com',
      // country,
      // business_name: businessName,
      // legal_entity: {
      //   business_name: businessName,
      //   first_name: firstName,
      //   last_name: lastName,
      //   additional_owners: '',
      //   address: {
      //     city: address.city,
      //     state: address.state || null,
      //     country,
      //     postal_code: address.postalCode,
      //     line1: address.line1,
      //     line2: address.line2 || null,
      //   },
      //   business_tax_id: businessTaxId,
      //   type: 'company',
      //   dob: {
      //     year: dateOfBirth.year,
      //     month: dateOfBirth.month,
      //     day: dateOfBirth.day,
      //   },
      //   ssn_last_4: last4,
      // },
      // external_account: externalAccount,
      // tos_acceptance: {
      //   ip,
      //   date: moment().utc().unix(),
      // },
    });
  }

  // come back to this once we upgrade the version of stripe npm that we are using
  // /**
  //  * @method
  //  * @param {Object} args               object contains named arguments
  //  * @param {string} args.stripeAccountId stripe account id
  //  * @param {string} args.country       where studio is in
  //  * @param {string} args.firstName     of the account owner
  //  * @param {string} args.lastName      of the account owner
  //  * @param {Object} args.dateOfBirth   of the owner, has keys: month, day, year
  //  * @param {string} args.businessPhone phone of the business w the connected account
  //  * @param {string} args.email         of the account owner
  //  * @param {Object} args.address       of the business, has keys: line1, line2?, city, state?, postalCode
  //  * @param {string} args.last4         ssn of the business owner
  //  * @returns {Promise<Object>} resolves Stripe response
  //  */
  // createPersonForManagedAccount({
  //   stripeAccountId,
  //   country,
  //   firstName,
  //   lastName,
  //   dateOfBirth,
  //   businessPhone,
  //   email,
  //   address,
  //   last4,
  // }) {
  //   // console.log('Setting the stripe API version');
  //   this.stripe.setApiVersion('2020-03-02');
  //   return this.stripe.accounts.createPerson(
  //     stripeAccountId, {
  //       first_name: firstName, 
  //       last_name: lastName,
  //       dob: {
  //         day: dateOfBirth.day,
  //         month: dateOfBirth.month,
  //         year: dateOfBirth.year,
  //       },
  //       relationship: {
  //         representative: true,
  //         owner: true,
  //       },
  //       address: {
  //         city: address.city,
  //         line1: address.line1,
  //         line2: address.line2 || null,
  //         state: address.state || null,
  //         postal_code: address.postalCode,
  //         country,        
  //       },
  //       ssn_last_4: last4,
  //       email,
  //       phone: businessPhone,
  //     },
  //     // function(err, person) {
  //     //   // asynchronously called
  //     // }
  //   );
  // }

  /**
   * @method
   * @param {Object} args               object has named arguments
   * @param {string} args.account       stripe_account_id of the studio
   * @param {string} args.country       where the studio is
   * @param {string} args.currency      of the studio
   * @param {number} args.accountNumber of the bank account
   * @param {number} args.routingNumber of the bank account
   * @returns {Promise<Object>} resolves Stripe response
   */
  addBankAccount({
    account,
    country,
    currency,
    accountNumber,
    routingNumber,
  }) {
    return this.stripe.accounts.createExternalAccount(account, {
      external_account: {
        object: 'bank_account',
        currency,
        country,
        account_number: accountNumber,
        routing_number: routingNumber,
      },
    });
  }

  /**
   * @method
   * @param {Object} args object has named arguments
   * @return {Promise<Object>} resolve Stripe response
   */
  uploadIDFile({
    data,
    name,
    account,
  }) {
    return this.stripe.fileUploads.create({
      purpose: 'identity_document',
      file: {
        data,
        name,
        type: 'application/octet-stream',
      },
    }, {
      stripe_account: account,
    });
  }

  /**
   * @method
   * @param {string} account stripe_account_id of the studio
   * @param {string} fileId to verify
   * @return {Promise<Object>} resolve Stripe response
   */
  verifyID(account, fileId) {
    return this.stripe.accounts.update(account, {
      legal_entity: {
        verification: {
          document: fileId,
        },
      },
    });
  }

  /**
   * @method
   * @param {string} account id where the plan is
   * @param {Object} plan details for Stripe
   * @return {Promise<Object>} resolve Stripe response
   */
  createPlan(account, plan) {
    return this.stripe.plans.create(plan, { stripe_account: account });
  }

  /**
   * @method
   * @param {string} stripeAccountId where the plan is
   * @param {string} managedAccountCustomerId who the plan is for
   * @param {string} stripePlanId of the plan
   * @param {string} applicationFeePercent dibs fee percent
   * @param {string} taxPercent tax percent based on location
   * @param {string} trialPeriodDays default 0 days
   * @param {string} coupon_id optional coupon to apply
   * @return {Promise<Object>} resolve Stripe response
   */
  subscribeToPlan({
    stripeAccountId,
    managedAccountCustomerId,
    stripePlanId,
    applicationFeePercent,
    taxPercent,
    trialPeriodDays,
    coupon,
   }) {
    return this.stripe.subscriptions.create({
      customer: managedAccountCustomerId,
      plan: stripePlanId,
      application_fee_percent: applicationFeePercent,
      tax_percent: taxPercent,
      trial_period_days: trialPeriodDays,
      coupon,
    }, {
      stripe_account: stripeAccountId,
    });
  }

  /**
   * @method
   * @param {string} stripeSubscriptionId stripe subscription
   * @param {string} stripeAccountId stripe account
   * @return {Promise<Object>} resolve Stripe response
   */
  cancelSubscriptionPlan({
    stripeSubscriptionId,
    stripeAccountId,
  }) {
    return this.stripe.subscriptions.del(stripeSubscriptionId, { stripe_account: stripeAccountId });
  }

  /**
   * @method
   * @param {Number} amount of the invoice item
   * @param {string} stripeAccountId where the plan is
   * @param {string} currency of the studio
   * @param {string} customer customerId for the invoice
   * @param {string} description how the invoice item will appear
   * @param {string} invoice invoiceId to add the item to
   * @return {Promise<Object>} resolve Stripe response
   */
  addInvoiceItemToInvoice({
    amount,
    currency,
    customer,
    description,
    invoice,
  }, stripeAccountId) {
    return this.stripe.invoiceItems.create({
      amount,
      currency,
      customer,
      description,
      invoice,
    }, { stripe_account: stripeAccountId });
  }

  /**
   * @method
   * @param {Object} args named argument object
   * @param {number} args.amount of charge
   * @param {Object} args.card user's card
   * @param {string} args.currency of the charge
   * @returns {number} stripe fee for the charge
   */
  getStripeFee({
    amount,
    card,
    currency,
  }) {
    let stripeFeePercentage;
    let stripeFeeFixed;
    switch (currency) {
      case 'GBP':
      case 'gbp':
        /*
        * If the currency of the charge is gbp, and the card is european, 1.4% + .20.
        * If the card is not european, 2.9% + .20
        */
        if (countryRegions[card.country.toUpperCase()] === 'Europe') {
          stripeFeePercentage = GBP_EURO_CARD_STRIPE_FEE_PERCENTAGE;
        } else {
          stripeFeePercentage = GBP_NON_EURO_CARD_STRIPE_FEE_PERCENTAGE;
        }
        stripeFeeFixed = GBP_STRIPE_FEE_FIXED;
        break;
      case 'USD':
      case 'usd':
      default:
        /*
        * If the currency is USD the rate is always 2.9% + .30
        */
        stripeFeePercentage = USD_STRIPE_FEE_PERECENTAGE;
        stripeFeeFixed = USD_STRIPE_FEE_FIXED;
    }
    return {
      percentage: +Decimal(amount).times(stripeFeePercentage).toDP(2),
      fixed: stripeFeeFixed,
      total: +Decimal(amount).times(stripeFeePercentage).toDP(2).plus(stripeFeeFixed),
    };
  }
  /**
   *
   * @param {string} subscriptionId  stripe identifier
   * @param {string} passExpiration  pass expiration date
   * @param {string} stripeAccountId managed account
   * @returns {promise} stripe method
   */
  addTrialPeriod(subscriptionId, passExpiration, stripeAccountId) {
    return this.stripe.subscriptions.update(subscriptionId,
      {
        prorate: false,
        trial_end: moment(passExpiration).unix(),
      },
      {
        stripe_account: stripeAccountId,
      }
    );
  }

  /**
  * Stripe Connect Bank Account Details
  * @param {string} stripeAccountId  stripe identifier
  * @returns {Promise} account data
  */
  retrieveBankAccounts(stripeAccountId) {
    return this.stripe.accounts.listExternalAccounts(stripeAccountId);
  }

  /**
  *
  * @param {string} refundId  stripe identifier
  * @returns {Promise} refund data
  */
  getRefundData(refundId) {
    return this.stripe.refunds.retrieve(refundId);
  }

  /**
  *
  * @param {String} stripeAccountId  stripe account identifier
  * @param {String} payoutId         payout identifier
  * @returns {Promise} refund data
  */
  getPayout(stripeAccountId, payoutId) {
    return this.stripe.payouts.retrieve(payoutId, { stripe_account: stripeAccountId });
  }

  /**
  * @param {Object} func          function to recurse over
  * @param {String} stripeAccount stripeAccount to call function on
  * @param {Object} opts          options to pass to Stripe
  * @param {Number} opts.limit            number of transactions to request to stripe at one time
  * @param {String} opts.payout           id of the payout to get connected account transactions for
  * @param {String} opts.type             limit the transactions to one type (ie. payment, payment_refund, charge, refund)
  * @param {Array<String>} opts.expand    list of strings that describe the elements to expand from the stripe API
  * @param {Array<Object>} acc    data accumulator
  * @returns {Promise} data response data
  */
  async recurseToGetAllData(func, stripeAccount, opts, acc = []) {
    const res = await func.call(this, stripeAccount, opts);
    const newAcc = acc.concat(res.data);
    if (res.has_more) {
      const newOpts = { ...opts, starting_after: res.data[res.data.length - 1].id };
      return this.recurseToGetAllData(func, stripeAccount, newOpts, newAcc);
    }
    return newAcc;
  }

  /**
  * getBalanceTransactions
  * @param {string} stripeAccount  stripe account id of the connected account
  * @param {Object} opts           options to pass to stripe
  * @param {Number} opts.limit            number of transactions to request to stripe at one time
  * @param {String} opts.payout           id of the payout to get connected account transactions for
  * @param {String} opts.type             limit the transactions to one type (ie. payment, payment_refund, charge, refund)
  * @param {Array<String>} opts.expand    list of strings that describe the elements to expand from the stripe API
  * @returns {Promise} res         response data
  */
  async getBalanceTransactions(stripeAccount, opts) {
    return this.stripe.balance.listTransactions(opts, stripeAccount);
  }

  /**
  *
  * @param {string} stripeAccount  stripe account id of the connected account
  * @param {Object} opts                  options to pass to stripe
  * @param {Number} opts.limit            number of transactions to request to stripe at one time
  * @param {String} opts.payout           id of the payout to get connected account transactions for
  * @param {String} opts.type             limit the transactions to one type (ie. payment, payment_refund, charge, refund)
  * @param {Array<String>} opts.expand    list of strings that describe the elements to expand from the stripe API
  * @returns {Promise} transaction data
  */
  getAllConnectedAccountTransactions(stripeAccount, opts) {
    return this.recurseToGetAllData(this.getBalanceTransactions, { stripe_account: stripeAccount }, { ...opts, limit: 100 });
  }

  /**
  * getPaymentTransactionsForPayout
  * @param {string} stripeAccount    stripe account id of the connected account
  * @param {string} payoutId         id of the payout
  * @returns {Promise} transaction data
  */
  getPaymentTransactionsForPayout(stripeAccount, payoutId) {
    return this.getAllConnectedAccountTransactions(stripeAccount, {
      payout: payoutId,
      expand: ['data.source.source_transfer.source_transaction'],
      type: 'payment',
    });
  }

  /**
  * getPaymentRefundTransactionsForPayout
  * @param {string} stripeAccount    stripe account id of the connected account
  * @param {string} payoutId         id of the payout
  * @returns {Promise} transaction data
  */
  getPaymentRefundTransactionsForPayout(stripeAccount, payoutId) {
    return this.getAllConnectedAccountTransactions(stripeAccount, {
      payout: payoutId,
      expand: ['data.source.source_transfer.source_transaction'],
      type: 'payment_refund',
    });
  }

  /**
  * getChargeTransactionsForPayout
  * @param {string} stripeAccount    stripe account id of the connected account
  * @param {string} payoutId         id of the payout
  * @returns {Promise} transaction data
  */
  getChargeTransactionsForPayout(stripeAccount, payoutId) {
    return this.getAllConnectedAccountTransactions(stripeAccount, {
      payout: payoutId,
      expand: ['data.source'],
      type: 'charge',
    });
  }

  /**
  * getRefundTransactionsForPayout
  * @param {string} stripeAccount    stripe account id of the connected account
  * @param {string} payoutId         id of the payout
  * @returns {Promise} transaction data
  */
  getRefundTransactionsForPayout(stripeAccount, payoutId) {
    return this.getAllConnectedAccountTransactions(stripeAccount, {
      limit: 100,
      payout: payoutId,
      expand: ['data.source'],
      type: 'refund',
    });
  }

  /**
   * @param {String} stripeAccount        stripe account id of the connected account
   * @param {String} chargeId             stripe charge id
   * @returns {Enum} refundType           type of refund (platform, platfrom_reverse_transfer, managed_account)
   */
  async getRefundType(stripeAccount, chargeId) {
    let managedAccountIdForCharge;
    let charge;
    try {
      charge = await this.retrieveChargeDetails(chargeId, stripeAccount);
      managedAccountIdForCharge = stripeAccount;
    } catch (err) {
      if (!err.message.includes('No such charge')) throw err;
    }
    switch (true) {
      case Boolean(managedAccountIdForCharge):
        // this case will only ever hit when retrieveChargeDetails returns a charge object successfully,
        // therefore its ok to call the application_fee property on the charge object
        return { refundType: RefundTypes.MANAGED_ACCOUNT, refundApplicationFee: Boolean(charge.application_fee) };
      case Boolean(stripeAccount):
        return { refundType: RefundTypes.PLATFORM_REVERSE_TRANSFER, refundApplicationFee: false };
      default:
        return { refundType: RefundTypes.PLATFORM, refundApplicationFee: false };
    }
  }

  /**
   * findOrCreateManagedAccountCustomer
   * @param {Object} args                         function arguments
   * @param {Object} args.user                    user for managed account customer find or create
   * @param {Object} args.studio                  studio to find or create customer account at
   * @returns {String} managedAccountCustomerId   stripe customer id for studio managed account
   */
  async findOrCreateManagedAccountCustomer({ user, studio }) {
    // If the user does not have a customer id in the managed connect
    // account for the studio, we need to create one
    const userStudio = await models.dibs_user_studio.findOne({
      where: {
        userid: user.id,
        dibs_studio_id: studio.id,
      },
    });
    if (!userStudio) throw new Error(`User ${user.id} must have a user studio to purchase at studio ${studio.name} - ${studio.id}.`);
    let managedAccountCustomerId = userStudio.stripe_customer_id;
    if (!managedAccountCustomerId) {
      // Need to get the token here to make sure the credit card transfers over
      const token = await this.createCustomerToken({ customerId: user.stripeid, managedAccount: studio.stripe_account_id });
      const managedAccountCustomer = await this.createCustomer({ email: user.email, source: token.id, managedAccount: studio.stripe_account_id });
      managedAccountCustomerId = managedAccountCustomer.id;
      userStudio.stripe_customer_id = managedAccountCustomerId;
      await userStudio.save();
    }
    return managedAccountCustomerId;
  }

  /**
   * findOrCreateManagedAccountCustomerPortal
   * @param {Object} args                         function arguments
   * @param {Object} args.user                    user for managed account customer find or create
   * @param {Object} args.studio                  studio to find or create customer account at
   * @returns {String} managedAccountCustomerId   stripe customer id for studio managed account
   */
  async findOrCreateManagedAccountCustomerPortal({ user, studio, userStudio }) {
    // If the user does not have a customer id in the managed connect
    // account for the studio, we need to create one
    if (!userStudio) throw new Error(`User ${user.id} must have a user studio to purchase at studio ${studio.name} - ${studio.id}.`);
    let managedAccountCustomerId = userStudio.stripe_customer_id;
    if (!managedAccountCustomerId) {
      // Need to get the token here to make sure the credit card transfers over
      const token = await this.createCustomerToken({ customerId: user.stripe_customer_id, managedAccount: studio.stripe_account_id });
      const managedAccountCustomer = await this.createCustomer({ email: user.email, source: token.id, managedAccount: studio.stripe_account_id });
      managedAccountCustomerId = managedAccountCustomer.id;
      userStudio.stripe_customer_id = managedAccountCustomerId;
      await userStudio.save();
    }
    return managedAccountCustomerId;
  }

  // Can whoever wrote this please document it?
  // eslint-disable-next-line require-jsdoc
  createPromoCodeCoupon(redeemBy, currency, { amountOff, percentOff, max_redemptions, accountId } = {}) {
    if (!amountOff && !percentOff) throw new Error('Code must apply some form of discount');
    const stripeObj = amountOff ? { amount_off: +Decimal(amountOff).times(100).toDP(0) } : { percent_off: percentOff };
    return this.stripe.coupons.create({
      ...stripeObj,
      redeem_by: moment(redeemBy).unix(),
      max_redemptions,
      duration: 'forever',
      currency,
    }, {
      stripe_account: accountId,
    });
  }
  /**
   * createProduct
   * @param {String} stripeAccount        stripe account id of the connected account
   * @param {String} productName                 name of the product
   * @returns {String} productID          ID for the newly created product in Stripe
   */
  async createProduct(stripeAccount, productName) {
    return this.stripe.products.create({
      name: productName,
      type: 'service',
    }, {
      stripe_account: stripeAccount,
    });
  }
  /**
   * createPricingPlan
   * @param {String} stripeAccount        stripe account id of the connected account
   * @param {String} productId                 id for the product
   * @param {String} intervalPeriod       intervals for billing product
   * @param {String} intervalCount        how often stripe should bill
   * @param {String} productName          to be used for the nickname of the plan
   * @param {Number} price                how much to charge
   * @returns {String} planID          ID for the newly created plan in Stripe
   */
  async createPricingPlan(stripeAccount, productId, intervalPeriod, intervalCount, productName, price) {
    return this.stripe.plans.create({
      currency: 'usd',
      interval: intervalPeriod,
      interval_count: intervalCount,
      product: productId,
      nickname: productName,
      amount: price,
    }, {
      stripe_account: stripeAccount,
    });
  }
}

module.exports = StripeClient;
